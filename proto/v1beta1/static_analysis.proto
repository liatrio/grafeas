// Copyright 2020 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This metadata type is heavily inspired and based on https://docs.sonarqube.org/latest/user-guide/metric-definitions/

syntax = "proto3";

package grafeas.v1beta1.static_analysis;

option go_package = "github.com/grafeas/grafeas/proto/v1beta1/static_analysis_go_proto";
option java_multiple_files = true;
option java_package = "io.grafeas.v1beta1.static_analysis";
option objc_class_prefix = "GRA";

import "google/protobuf/timestamp.proto";
import "proto/v1beta1/source.proto";

// Rating defines a common scoring system to use in different code quality dimensions.
enum Rating {
    A = 0;
    B = 1;
    C = 2;
    D = 3;
    E = 4;
}

// Code Complexity
message Complexity {
    // Cyclomatic Complexity calculated based on the number of paths through the code.
    // Whenever the control flow of a function splits, the complexity counter gets incremented by one.
    // Each function has a minimum complexity of 1.
    // This calculation varies slightly by language because keywords and functionalities do.
    uint32 cyclomatic = 1;
    // How hard it is to understand the code's control flow.
    // See https://www.sonarsource.com/resources/white-papers/cognitive-complexity.html
    // for a complete description of the mathematical model applied to compute this measure.
    uint32 cognitive = 2;
    // Optional list of findings (complexities)
    repeated Finding findings = 3;
}

// Code duplication
message Duplication {
    // Number of duplicated blocks of lines.
    uint32 blocks = 1;
    // Number of files involved in duplications.
    uint32 files = 2;
    // Number of lines involved in duplications.
    uint32 lines = 3;
    // The ratio of duplicated lines in relation to the total number of lines.
    // duplicated_lines / lines * 100
    float lines_density = 4;
    // Optional list of findings (duplications)
    repeated Finding findings = 5;
}

// Maintainability of the code or Software Quality Assessment based on Lifecycle Expectations (SQALE)
message Maintainability {
    // Total count of Code Smell issues.
    uint64 code_smells = 1;
    // Total count of Code Smell issues raised for the first time on New Code.
    uint64 new_code_smells = 2;
    // Rating given to your project related to the value of your sqale_debt_ratio. Values can be A, B, C, D or E.
    Rating sqale_rating = 3;
    // Effort to fix all Code Smells, in minutes.
    uint32 sqale_index = 4;
    // Effort to fix all Code Smells raised for the first time on New Code.
    uint32 new_technical_debt = 5;
    // Ratio between the cost to develop the software and the cost to fix it.
    // Ratio formula is: Remediation cost / Development cost
    // Which can be restated as:
    // Remediation cost / (Cost to develop 1 line of code * Number of lines of code)
    // The value of the cost to develop a line of code is 0.06 days.
    float sqale_debt_ratio = 6;
    // Ratio between the cost to develop the code changed on New Code and the cost of the issues linked to it.
    float new_sqale_debt_ratio = 7;
    // Optional list of findings (code smells)
    repeated Finding findings = 8;
}

message Reliability {
    // Number of bug issues.
    uint32 bugs = 1;
    // Number of new bug issues.
    uint32 new_bugs = 2;
    // Rating given based on the number of bugs and their criticality
    Rating rating = 3;
    // Rating based on new code
    Rating new_reliability_rating = 4;
    // Effort to fix all bug issues, in minutes.
    uint32 remediation_effort = 5;
    // Same as Reliability remediation effort but on the code changed on New Code.
    uint32 new_reliability_remediation_effort = 6;
    // Optional list of findings (bugs)
    repeated Finding findings = 7;
}

message Security {
    // Number of vulnerability issues.
    uint32 vulnerabilities = 1;
    // Number of vulnerability issues on new code.
    uint32 new_vulnerabilities = 2;
    // Security rating letter.
    Rating security_rating = 3;
    // Effort to fix all vulnerability issues, in minutes
    uint32 security_remediation_effort = 4;
    // Same as Security remediation effort but on the code changed on New Code
    uint32 new_security_remediation_effort = 5;
    // Number of Security hotspots
    uint32 security_hotspots = 6;
    // Security hotspots on new code
    uint32 new_security_hotspots = 7;
    // Letter grade based on the percentage of reviewed security hotspots
    Rating security_review_rating = 8;
    // Letter grade based on the percentage of reviewed security hotspots for new code
    Rating new_security_review_rating = 9;
    // Percentage of review security hotspots (review hotspots x 100)/(to_review hotspots + review hotspots)
    float security_hotspots_reviewed = 10;
    // Optional list of findings (vulnerabilites)
    repeated Finding findings = 11;
 }

message CodeSize {
    // Number of classes
    uint32 classes = 1;
    // Number of lines containing either comment or commented-out code.
    // Non-significant comment lines (empty comment lines, comment lines containing only
    // special characters, etc.) do not increase the number of comment lines.
    uint32 comment_lines = 2;
    // Density of comment lines = Comment lines / (Lines of code + Comment lines) * 100
    // With such a formula:
    // 50% means that the number of lines of code equals the number of comment lines
    // 100% means that the file only contains comment lines
    float comment_lines_density = 3;
    // Number of directories.
    uint32 directories = 4;
    // Number of files.
    uint64 files = 5;
    // Number of physical lines (number of carriage returns).
    uint64 lines = 6;
    // Lines of code. Number of physical lines that contain at least one character which is neither a whitespace nor
    // a tabulation nor part of a comment.
    uint64 ncloc = 7;
    // Number of functions. Depending on the language, a function is either a function or a method or a paragraph.
    uint64 functions = 8;
    // Number of statements.
    uint64 statements = 9;
    // Optional list of findings (code size)
    repeated Finding findings = 10;
}

message Issues {
    // Total count of issues in all states.
    uint32 total = 1;
    // // Total count of issues on New code
    uint32 new_total = 2;
    // Total count of blocking issues.
    uint32 blocker = 3;
    // Total count of critical issues.
    uint32 critical = 4;
    // Total count of major issues.
    uint32 major = 5;
    // Total count of minor issues.
    uint32 minor = 6;
    // Total count of info issues.
    uint32 info = 7;
    // Total count of blocking issues on New Code.
    uint32 new_blocker = 8;
    // Total count of critical issues on New Code.
    uint32 new_critical = 9;
    // Total count of major issues on New Code.
    uint32 new_major = 10;
    // Total count of minor issues on New Code.
    uint32 new_minor = 11;
    // Total count of info issues on New Code.
    uint32 new_info = 12;
    // Total count of issues marked False Positive.
    uint32 false_positives = 13;
    // Total count of issues in the Open state.
    uint32 open = 14;
    // Total count of issues in the Confirmed state.
    uint32 confirmed = 15;
    // Total count of issues in the Reopened state
    uint32 reopened = 16;
    // Optional list of findings (issues)
    repeated Finding findings = 17;
}

message Tests {
    // On each line of code containing some boolean expressions, the condition coverage simply answers the following question: 'Has each boolean expression been evaluated both to true and false?'. This is the density of possible conditions in flow control structures that have been followed during unit tests execution.
    float condition_coverage = 1;
    // Identical to Condition coverage but restricted to new / updated source code.
    float new_conition_coverage = 2;
    // XXXXXXXXX List of covered conditions.
    string condition_coverage_hits = 3;
    // XXXXXXXXX Number of conditions by line.
    uint32 conditions_by_line = 4;
    // XXXXXXXXXX Number of covered conditions by line.
    uint32 covered_conditions_by_line = 5;
    // XXXXXXXXXX It is a mix of Line coverage and Condition coverage. Its goal is to provide an even more accurate answer to the following question: How much of the source code has been covered by the unit tests?
    float coverage = 6;
    // Identical to Coverage but restricted to new / updated source code.
    float new_coverage = 8;
    // On a given line of code, Line coverage simply answers the following question: Has this line of code been executed during the execution of the unit tests?.
    float line_coverage = 9;
    // Identical to Line coverage but restricted to new / updated source code.
    float new_line_coverage = 10;
    // Number of lines of code which could be covered by unit tests (for example, blank lines or full comments lines are not considered as lines to cover).
    uint32 lines_to_cover = 11;
    // Identical to Lines to cover but restricted to new / updated source code.
    uint32 new_lines_to_cover = 12;
    //Number of skipped unit tests.
    uint32 skipped_tests = 13;
    // Number of conditions which are not covered by unit tests.
    uint32 uncovered_conditions = 14;
    // Identical to Uncovered conditions but restricted to new / updated source code.
    uint32 new_uncovered_conditions = 15;
    // Number of lines of code which are not covered by unit tests.
    uint32 uncovered_lines = 16;
    // Identical to Uncovered lines but restricted to new / updated source code.
    uint32 new_uncovered_lines = 17;
    // Number of unit tests.
    uint32 tests = 18;
    // Time required to execute all the unit tests. Milliseconds
    uint64 test_execution_time = 19;
    // Number of unit tests that have failed.
    uint32 test_errors = 20;
    // Number of unit tests that have failed with an unexpected exception.
    uint32 test_failures = 21;
    // Test success density = (Unit tests - (Unit test errors + Unit test failures)) / Unit tests * 100
    float test_success_density = 22;

}

// QualityGate provides information about the quality gate and its status
message QualityGate {
    // Name of the quality gate used
    string quality_gate_name = 1;
    // Name of the quality profile used
    string quality_profile_name = 2;
    // State of the Quality Gate associated to your Project. Possible values are : ERROR, OK WARN value has been removed since 7.6.
    string quality_gate_status = 3;
    // For all the conditions of your Quality Gate, you know which condition is failing and which is not.
    string quality_gate_details = 4;
}

// FileLocation defines the exact location for a given analysis result.
message FileLocation {
    // Absolute File system path.
    string file_path = 1;
    // File line number.
    uint64 line_number = 2;
    // Start index within the line number.
    uint32 start_column = 3;
    // End index within the line number.
    uint32 end_column = 4;
}

message Finding {
    // File location of the analsys results.
    FileLocation file_location = 1;
    // A name or title of the finding
    string name = 2;
    // Identifier for the finding
    string id = 3;
    // A description for the finding
    string description = 4;
}

// Static Analysis statistics.
message Stats {
    // Cyclomatic and cognitive complexity stats
    Complexity complexity = 1;
    // Code duplication
    Duplication duplication = 2;
    // Software Quality Assessment based on Lifecycle Expectations (SQALE)
    Maintainability maintainability = 3;
    // Reliability stats
    Reliability reliability = 4;
    // Security stats
    Security security = 5;
    // Code size
    CodeSize code_size = 6;
    // Issues found
    Issues issues = 7;
    // Quality Gate information
    QualityGate quality_gate = 8;
    // Tests stats
    Tests tests = 9;
}

// StaticAnalysis is the Note for static analyses on pieces of code.
message StaticAnalysis {
    // Analysis tool involved.
    string tool = 1;
    // Version of the analysis tool used.
    string tool_version = 2;
    // Analysis tool configuration at the time of the analysis run.
    string tool_config = 3;
    // Overall code quality stats
    Stats summary = 4;
   //Source context were the analysis ran.
    grafeas.v1beta1.source.SourceContext context = 5;
    // Time at which execution of the analysis was started.
    google.protobuf.Timestamp start_time = 6;
    // Time at which execution of the analysis was finished.
    google.protobuf.Timestamp end_time = 7;
}

// Details is an Occurrence that contains the static analysis results.
message Details {
    StaticAnalysis analysis_results = 1;
}
